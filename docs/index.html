<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simulate X-ray Diffraction from Polycrystals in 3D. &mdash; xrd_simulator 0.0.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/copybutton.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="#">
            <img src="_static/logo_stripped_white.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li><a class="reference internal" href="#">Simulate X-ray Diffraction from Polycrystals in 3D.</a></li>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#installation">Installation</a><ul>
<li><a class="reference internal" href="#anaconda-installation-linux-and-macos">Anaconda installation (Linux and Macos)</a></li>
<li><a class="reference internal" href="#anaconda-installation-windows">Anaconda installation (Windows)</a></li>
<li><a class="reference internal" href="#pip-installation">Pip Installation</a></li>
<li><a class="reference internal" href="#source-installation">Source installation</a></li>
<li><a class="reference internal" href="#credits">Credits</a></li>
</ul>
</li>
<li><a class="reference internal" href="#documentation">Documentation</a><ul>
<li><a class="reference internal" href="#module-xrd_simulator.polycrystal">polycrystal</a></li>
<li><a class="reference internal" href="#module-xrd_simulator.mesh">mesh</a></li>
<li><a class="reference internal" href="#module-xrd_simulator.phase">phase</a></li>
<li><a class="reference internal" href="#module-xrd_simulator.beam">beam</a></li>
<li><a class="reference internal" href="#module-xrd_simulator.detector">detector</a></li>
<li><a class="reference internal" href="#module-xrd_simulator.motion">motion</a></li>
<li><a class="reference internal" href="#module-xrd_simulator.templates">templates</a></li>
<li><a class="reference internal" href="#module-xrd_simulator.scattering_unit">scattering_unit</a></li>
<li><a class="reference internal" href="#module-xrd_simulator.laue">laue</a></li>
</ul>
</li>
</ul>
</div>
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">xrd_simulator</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
      <li>Simulate X-ray Diffraction from Polycrystals in 3D.</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/index.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="toctree-wrapper compound">
</div>
<img alt="https://github.com/FABLE-3DXRD/xrd_simulator/blob/main/docs/source/images/logo.png?raw=true" src="https://github.com/FABLE-3DXRD/xrd_simulator/blob/main/docs/source/images/logo.png?raw=true" />
<a class="reference external image-reference" href="https://pypi.org/project/xrd-simulator/"><img alt="https://img.shields.io/pypi/pyversions/xrd-simulator.svg?" src="https://img.shields.io/pypi/pyversions/xrd-simulator.svg?" /></a>
<a class="reference external image-reference" href="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/python-package-conda-linux-py38.yml"><img alt="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/python-package-run-tests-linux-py38.yml/badge.svg?" src="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/python-package-run-tests-linux-py38.yml/badge.svg?" /></a>
<a class="reference external image-reference" href="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/python-package-conda-macos-py38.yml"><img alt="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/python-package-run-tests-macos-py38.yml/badge.svg?" src="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/python-package-run-tests-macos-py38.yml/badge.svg?" /></a>
<a class="reference external image-reference" href="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/python-package-conda-linux-py38.yml"><img alt="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/python-package-conda-linux-py38.yml/badge.svg?" src="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/python-package-conda-linux-py38.yml/badge.svg?" /></a>
<a class="reference external image-reference" href="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/python-package-conda-macos-py38.yml"><img alt="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/python-package-conda-macos-py38.yml/badge.svg?" src="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/python-package-conda-macos-py38.yml/badge.svg?" /></a>
<a class="reference external image-reference" href="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/pages/pages-build-deployment/"><img alt="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/pages/pages-build-deployment/badge.svg?" src="https://github.com/FABLE-3DXRD/xrd_simulator/actions/workflows/pages/pages-build-deployment/badge.svg?" /></a>
<a class="reference external image-reference" href="https://pypi.org/project/xrd-simulator/"><img alt="https://badge.fury.io/py/xrd-simulator.svg?" src="https://badge.fury.io/py/xrd-simulator.svg?" /></a>
<a class="reference external image-reference" href="https://anaconda.org/conda-forge/xrd_simulator/"><img alt="https://anaconda.org/conda-forge/xrd_simulator/badges/installer/conda.svg?" src="https://anaconda.org/conda-forge/xrd_simulator/badges/installer/conda.svg?" /></a>
<a class="reference external image-reference" href="https://anaconda.org/conda-forge/xrd_simulator/"><img alt="https://anaconda.org/conda-forge/xrd_simulator/badges/platforms.svg?" src="https://anaconda.org/conda-forge/xrd_simulator/badges/platforms.svg?" /></a>
<a class="reference external image-reference" href="https://anaconda.org/conda-forge/xrd_simulator/"><img alt="https://anaconda.org/conda-forge/xrd_simulator/badges/latest_release_relative_date.svg?" src="https://anaconda.org/conda-forge/xrd_simulator/badges/latest_release_relative_date.svg?" /></a>
<section id="simulate-x-ray-diffraction-from-polycrystals-in-3d">
<h1>Simulate X-ray Diffraction from Polycrystals in 3D.<a class="headerlink" href="#simulate-x-ray-diffraction-from-polycrystals-in-3d" title="Permalink to this headline"></a></h1>
<a class="reference external image-reference" href="https://github.com/FABLE-3DXRD/xrd_simulator/"><img alt="https://img.shields.io/badge/stability-alpha-f4d03f.svg?" src="https://img.shields.io/badge/stability-alpha-f4d03f.svg?" /></a>
<p>The <strong>X</strong>-<strong>R</strong> ay <strong>D</strong> iffraction <strong>SIMULATOR</strong> package defines polycrystals as a mesh of tetrahedral single crystals
and simulates diffraction as collected by a 2D discretized detector array while the sample is rocked
around an arbitrary rotation axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">xrd_simulator</span></code> was originally developed with the hope to answer questions about measurement optimization in
scanning x-ray diffraction experiments. However, <code class="docutils literal notranslate"><span class="pre">xrd_simulator</span></code> can simulate a wide range of experimental
diffraction setups. The essential idea is that the sample and beam topology can be arbitrarily specified,
and their interaction simulated as the sample is rocked. This means that standard “non-powder” experiments
such as <a class="reference external" href="https://doi.org/10.1107/S1600576720001016">scanning-3dxrd</a> and full-field <a class="reference external" href="https://en.wikipedia.org/wiki/3DXRD">3dxrd</a> (or HEDM if you like) can be simulated as well as more advanced
measurement sequences such as helical scans for instance. It is also possible to simulate <a class="reference external" href="https://en.wikipedia.org/wiki/Powder_diffraction">powder like</a>
scenarios using orientation density functions as input.</p>
</section>
<section id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline"></a></h1>
<p>Before reading all the boring documentation (<a class="reference external" href="https://FABLE-3DXRD.github.io/xrd_simulator/">which is hosted here</a>) let’s dive into some end to end
examples to get us started on a good flavour.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">xrd_simulator</span></code> is built around four python objects which reflect a diffraction experiment:</p>
<blockquote>
<div><ul class="simple">
<li><p>A <strong>beam</strong> of x-rays (using the <code class="docutils literal notranslate"><span class="pre">xrd_simulator.beam</span></code> module)</p></li>
<li><p>A 2D area <strong>detector</strong> (using the <code class="docutils literal notranslate"><span class="pre">xrd_simulator.detector</span></code> module)</p></li>
<li><p>A 3D <strong>polycrystal</strong> sample (using the <code class="docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal</span></code> module)</p></li>
<li><p>A rigid body sample <strong>motion</strong> (using the <code class="docutils literal notranslate"><span class="pre">xrd_simulator.motion</span></code> module)</p></li>
</ul>
</div></blockquote>
<p>Once these objects are defined it is possible to let the <strong>detector</strong> collect scattering of the <strong>polycrystal</strong>
as the sample undergoes the prescribed rigid body <strong>motion</strong> while being illuminated by the xray <strong>beam</strong>.</p>
<p>Let’s go ahead and build ourselves some x-rays:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">xrd_simulator.beam</span> <span class="kn">import</span> <span class="n">Beam</span>
<span class="c1"># The beam of xrays is represented as a convex polyhedron</span>
<span class="c1"># We specify the vertices in a numpy array.</span>
<span class="n">beam_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="o">-</span><span class="mf">1e6</span><span class="p">,</span> <span class="o">-</span><span class="mf">500.</span><span class="p">,</span> <span class="o">-</span><span class="mf">500.</span><span class="p">],</span>
    <span class="p">[</span><span class="o">-</span><span class="mf">1e6</span><span class="p">,</span> <span class="mf">500.</span><span class="p">,</span> <span class="o">-</span><span class="mf">500.</span><span class="p">],</span>
    <span class="p">[</span><span class="o">-</span><span class="mf">1e6</span><span class="p">,</span> <span class="mf">500.</span><span class="p">,</span> <span class="mf">500.</span><span class="p">],</span>
    <span class="p">[</span><span class="o">-</span><span class="mf">1e6</span><span class="p">,</span> <span class="o">-</span><span class="mf">500.</span><span class="p">,</span> <span class="mf">500.</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">1e6</span><span class="p">,</span> <span class="o">-</span><span class="mf">500.</span><span class="p">,</span> <span class="o">-</span><span class="mf">500.</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">1e6</span><span class="p">,</span> <span class="mf">500.</span><span class="p">,</span> <span class="o">-</span><span class="mf">500.</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">1e6</span><span class="p">,</span> <span class="mf">500.</span><span class="p">,</span> <span class="mf">500.</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">1e6</span><span class="p">,</span> <span class="o">-</span><span class="mf">500.</span><span class="p">,</span> <span class="mf">500.</span><span class="p">]])</span>

<span class="n">beam</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span>
    <span class="n">beam_vertices</span><span class="p">,</span>
    <span class="n">xray_propagation_direction</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span>
    <span class="n">wavelength</span><span class="o">=</span><span class="mf">0.28523</span><span class="p">,</span>
    <span class="n">polarization_vector</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]))</span>
</pre></div>
</div>
</div></blockquote>
<p>We will also need to define a detector:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xrd_simulator.detector</span> <span class="kn">import</span> <span class="n">Detector</span>
<span class="c1"># The detector plane is defined by it&#39;s corner coordinates det_corner_0,det_corner_1,det_corner_2</span>
<span class="n">detector</span> <span class="o">=</span> <span class="n">Detector</span><span class="p">(</span><span class="n">pixel_size_z</span><span class="o">=</span><span class="mf">75.0</span><span class="p">,</span>
                    <span class="n">pixel_size_y</span><span class="o">=</span><span class="mf">55.0</span><span class="p">,</span>
                    <span class="n">det_corner_0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">142938.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">38400.</span><span class="p">,</span> <span class="o">-</span><span class="mf">38400.</span><span class="p">]),</span>
                    <span class="n">det_corner_1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">142938.3</span><span class="p">,</span> <span class="mf">38400.</span><span class="p">,</span> <span class="o">-</span><span class="mf">38400.</span><span class="p">]),</span>
                    <span class="n">det_corner_2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">142938.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">38400.</span><span class="p">,</span> <span class="mf">38400.</span><span class="p">]))</span>
</pre></div>
</div>
</div></blockquote>
<p>Next we go ahead and produce a sample, to do this we need to first define a mesh that
describes the topology of the sample, in this example we make the sample shaped as a ball:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xrd_simulator.mesh</span> <span class="kn">import</span> <span class="n">TetraMesh</span>
<span class="c1"># xrd_simulator supports several ways to generate a mesh, here we</span>
<span class="c1"># generate meshed solid sphere using a level set.</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">TetraMesh</span><span class="o">.</span><span class="n">generate_mesh_from_levelset</span><span class="p">(</span>
    <span class="n">level_set</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mf">768.0</span><span class="p">,</span>
    <span class="n">bounding_radius</span><span class="o">=</span><span class="mf">769.0</span><span class="p">,</span>
    <span class="n">max_cell_circumradius</span><span class="o">=</span><span class="mf">450.</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Every element in the sample is composed of some material, or “phase”, we define the present phases
in a list of <code class="docutils literal notranslate"><span class="pre">xrd_simulator.phase.Phase</span></code> objects, in this example only a single phase is present:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xrd_simulator.phase</span> <span class="kn">import</span> <span class="n">Phase</span>
<span class="n">quartz</span> <span class="o">=</span> <span class="n">Phase</span><span class="p">(</span><span class="n">unit_cell</span><span class="o">=</span><span class="p">[</span><span class="mf">4.926</span><span class="p">,</span> <span class="mf">4.926</span><span class="p">,</span> <span class="mf">5.4189</span><span class="p">,</span> <span class="mf">90.</span><span class="p">,</span> <span class="mf">90.</span><span class="p">,</span> <span class="mf">120.</span><span class="p">],</span>
               <span class="n">sgname</span><span class="o">=</span><span class="s1">&#39;P3221&#39;</span><span class="p">,</span>  <span class="c1"># (Quartz)</span>
               <span class="n">path_to_cif_file</span><span class="o">=</span><span class="kc">None</span>  <span class="c1"># phases can be defined from crystalographic information files</span>
               <span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The polycrystal sample can now be created. In this example the crystal elements have random orientations
and the strain is uniformly zero in the sample:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.spatial.transform</span> <span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="kn">from</span> <span class="nn">xrd_simulator.polycrystal</span> <span class="kn">import</span> <span class="n">Polycrystal</span>
<span class="n">orientation</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">number_of_elements</span><span class="p">)</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="n">polycrystal</span> <span class="o">=</span> <span class="n">Polycrystal</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                          <span class="n">orientation</span><span class="p">,</span>
                          <span class="n">strain</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
                          <span class="n">phases</span><span class="o">=</span><span class="n">quartz</span><span class="p">,</span>
                          <span class="n">element_phase_map</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="c1"># The polycrystal can be saved to file using: Polycrystal.save()</span>
</pre></div>
</div>
</div></blockquote>
<p>We can visualize the sample by saving to file and opening it in your favorite 3D rendering program.
In <a class="reference external" href="https://www.paraview.org/">paraview</a> the sampled colored by one of its Euler angles looks like this:</p>
<img alt="https://github.com/FABLE-3DXRD/xrd_simulator/blob/main/docs/source/images/example_polycrystal_readme.png?raw=true" class="align-center" src="https://github.com/FABLE-3DXRD/xrd_simulator/blob/main/docs/source/images/example_polycrystal_readme.png?raw=true" />
<p>We can now define some motion of the sample over which to integrate the diffraction signal:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xrd_simulator.motion</span> <span class="kn">import</span> <span class="n">RigidBodyMotion</span>
<span class="n">motion</span> <span class="o">=</span> <span class="n">RigidBodyMotion</span><span class="p">(</span><span class="n">rotation_axis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)]),</span>
                         <span class="n">rotation_angle</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">1.0</span><span class="p">),</span>
                         <span class="n">translation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">123</span><span class="p">,</span> <span class="o">-</span><span class="mf">153.3</span><span class="p">,</span> <span class="mf">3.42</span><span class="p">]))</span>
</pre></div>
</div>
</div></blockquote>
<p>Now that we have an experimental setup we may collect diffraction by letting the beam and detector
interact with the sample:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">polycrystal</span><span class="o">.</span><span class="n">diffract</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">detector</span><span class="p">,</span> <span class="n">motion</span><span class="p">)</span>
<span class="n">diffraction_pattern</span> <span class="o">=</span> <span class="n">detector</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">frame_number</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                        <span class="n">lorentz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">polarization</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">structure_factor</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;project&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The resulting rendered detector frame looks something like this:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">diffraction_pattern</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<img alt="https://github.com/FABLE-3DXRD/xrd_simulator/blob/main/docs/source/images/diffraction_pattern.png?raw=true" class="align-center" src="https://github.com/FABLE-3DXRD/xrd_simulator/blob/main/docs/source/images/diffraction_pattern.png?raw=true" />
<p>To compute several frames simply change the motion and collect the diffraction again. The sample may be moved before
each computation using the same or another motion.</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">polycrystal</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">motion</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
<span class="n">polycrystal</span><span class="o">.</span><span class="n">diffract</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">detector</span><span class="p">,</span> <span class="n">motion</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Many more options for experimental setups and intensity rendering exist, have fun experimenting!
The above example code can be found as a <a class="reference external" href="https://github.com/FABLE-3DXRD/xrd_simulator/blob/main/docs/source/examples/example_readme.py">single .py file here.</a></p>
</section>
<section id="installation">
<h1>Installation<a class="headerlink" href="#installation" title="Permalink to this headline"></a></h1>
<section id="anaconda-installation-linux-and-macos">
<h2>Anaconda installation (Linux and Macos)<a class="headerlink" href="#anaconda-installation-linux-and-macos" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">xrd_simulator</span></code> is distributed on the <a class="reference external" href="https://anaconda.org/conda-forge/xrd_simulator">conda-forge channel</a> and the preferred way to install
the xrd_simulator package is via <a class="reference external" href="https://www.anaconda.com/products/individual">Anaconda</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">install</span> <span class="o">-</span><span class="n">c</span> <span class="n">conda</span><span class="o">-</span><span class="n">forge</span> <span class="n">xrd_simulator</span>
</pre></div>
</div>
<p>This is meant work across OS-systems and requires an <a class="reference external" href="https://www.anaconda.com/products/individual">Anaconda</a> itself installation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">xrd_simulator</span></code> works on python versions =&gt;3.8&lt;3.9. Make sure your conda environment has the right
python version before installation. For instance, creating a new conda python 3.8 environment as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">conda</span> <span class="n">create</span> <span class="o">-</span><span class="n">n</span> <span class="n">xrd_simulator</span> <span class="n">python</span><span class="o">=</span><span class="mf">3.8</span>
<span class="n">conda</span> <span class="n">activate</span> <span class="n">xrd_simulator</span>
</pre></div>
</div>
<p>before to installing can be a good idea.</p>
</aside>
<p>(The conda-forge feedstock of <code class="docutils literal notranslate"><span class="pre">xrd_simulator</span></code> <a class="reference external" href="https://github.com/conda-forge/xrd_simulator-feedstock">can be found here.</a>)</p>
</section>
<section id="anaconda-installation-windows">
<h2>Anaconda installation (Windows)<a class="headerlink" href="#anaconda-installation-windows" title="Permalink to this headline"></a></h2>
<p>To install with anaconda on windows you must make sure that external dependencies of <a class="reference external" href="https://github.com/nschloe/pygalmesh">pygalmesh</a> are preinstalled
on your system. Documentation on installing these package <a class="reference external" href="https://github.com/nschloe/pygalmesh#installation">can be found elsewhere.</a></p>
</section>
<section id="pip-installation">
<h2>Pip Installation<a class="headerlink" href="#pip-installation" title="Permalink to this headline"></a></h2>
<p>Pip installation is possible, however, external dependencies of <a class="reference external" href="https://github.com/nschloe/pygalmesh">pygalmesh</a> must the be preinstalled
on your system. Installation of these will be OS dependent and documentation
<a class="reference external" href="https://github.com/nschloe/pygalmesh#installation">can be found elsewhere.</a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="n">xrd</span><span class="o">-</span><span class="n">simulator</span>
</pre></div>
</div>
</section>
<section id="source-installation">
<h2>Source installation<a class="headerlink" href="#source-installation" title="Permalink to this headline"></a></h2>
<p>Naturally one may also install from the sources:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">git</span> <span class="n">clone</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">github</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">FABLE</span><span class="o">-</span><span class="mi">3</span><span class="n">DXRD</span><span class="o">/</span><span class="n">xrd_simulator</span><span class="o">.</span><span class="n">git</span>
<span class="n">cd</span> <span class="n">xrd_simulator</span>
<span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span>
</pre></div>
</div>
<p>This will then again require the <a class="reference external" href="https://github.com/nschloe/pygalmesh">pygalmesh</a> dependencies to be resolved beforehand.</p>
</section>
<section id="credits">
<h2>Credits<a class="headerlink" href="#credits" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">xrd_simulator</span></code> makes good use of xfab and pygalmesh. The source code of these repos can be found here:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://github.com/FABLE-3DXRD/xfab">https://github.com/FABLE-3DXRD/xfab</a></p></li>
<li><p><a class="reference external" href="https://github.com/nschloe/pygalmesh">https://github.com/nschloe/pygalmesh</a></p></li>
</ul>
</section>
</section>
<section id="documentation">
<h1>Documentation<a class="headerlink" href="#documentation" title="Permalink to this headline"></a></h1>
<section id="module-xrd_simulator.polycrystal">
<span id="polycrystal"></span><h2>polycrystal<a class="headerlink" href="#module-xrd_simulator.polycrystal" title="Permalink to this headline"></a></h2>
<p>The polycrystal module is used to represent a polycrystalline sample. The <a class="reference internal" href="#xrd_simulator.polycrystal.Polycrystal" title="xrd_simulator.polycrystal.Polycrystal"><code class="xref py py-class docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal.Polycrystal</span></code></a>
object holds the function <a class="reference internal" href="#xrd_simulator.polycrystal.Polycrystal.diffract" title="xrd_simulator.polycrystal.Polycrystal.diffract"><code class="xref py py-func docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal.Polycrystal.diffract()</span></code></a> which may be used to compute diffraction.
To move the sample spatially, the function <a class="reference internal" href="#xrd_simulator.polycrystal.Polycrystal.transform" title="xrd_simulator.polycrystal.Polycrystal.transform"><code class="xref py py-func docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal.Polycrystal.transform()</span></code></a> can be used.
Here is a minimal example of how to instantiate a polycrystal object and save it to disc:</p>
<blockquote>
<div><dl>
<dt>Examples:</dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.transform</span> <span class="kn">import</span> <span class="n">Rotation</span> <span class="k">as</span> <span class="n">R</span>
<span class="kn">from</span> <span class="nn">xrd_simulator.mesh</span> <span class="kn">import</span> <span class="n">TetraMesh</span>
<span class="kn">from</span> <span class="nn">xrd_simulator.phase</span> <span class="kn">import</span> <span class="n">Phase</span>
<span class="kn">from</span> <span class="nn">xrd_simulator.polycrystal</span> <span class="kn">import</span> <span class="n">Polycrystal</span>

<span class="c1"># The toplogy of the polycrystal is described by a tetrahedral mesh,</span>
<span class="c1"># xrd_simulator supports several ways to generate a mesh, here we</span>
<span class="c1"># generate meshed solid sphere using a level set.</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">TetraMesh</span><span class="o">.</span><span class="n">generate_mesh_from_levelset</span><span class="p">(</span>
    <span class="n">level_set</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="mf">768.0</span><span class="p">,</span>
    <span class="n">bounding_radius</span><span class="o">=</span><span class="mf">769.0</span><span class="p">,</span>
    <span class="n">max_cell_circumradius</span><span class="o">=</span><span class="mf">450.</span><span class="p">)</span>

<span class="c1"># Each element of the mesh is a single crystal with properties defined</span>
<span class="c1"># by an xrd_simulator.phase.Phase object.</span>
<span class="n">quartz</span> <span class="o">=</span> <span class="n">Phase</span><span class="p">(</span><span class="n">unit_cell</span><span class="o">=</span><span class="p">[</span><span class="mf">4.926</span><span class="p">,</span> <span class="mf">4.926</span><span class="p">,</span> <span class="mf">5.4189</span><span class="p">,</span> <span class="mf">90.</span><span class="p">,</span> <span class="mf">90.</span><span class="p">,</span> <span class="mf">120.</span><span class="p">],</span>
               <span class="n">sgname</span><span class="o">=</span><span class="s1">&#39;P3221&#39;</span><span class="p">,</span>  <span class="c1"># (Quartz)</span>
               <span class="n">path_to_cif_file</span><span class="o">=</span><span class="kc">None</span>  <span class="c1"># phases can be defined from crystalographic information files</span>
               <span class="p">)</span>

<span class="c1"># The polycrystal can now map phase(s) (only quartz here), orientations and</span>
<span class="c1"># strains to the tetrahedral mesh elements.</span>
<span class="n">orientation</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">number_of_elements</span><span class="p">)</span><span class="o">.</span><span class="n">as_matrix</span><span class="p">()</span>
<span class="n">polycrystal</span> <span class="o">=</span> <span class="n">Polycrystal</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span>
                          <span class="n">orientation</span><span class="p">,</span>
                          <span class="n">strain</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span>
                          <span class="n">phases</span><span class="o">=</span><span class="n">quartz</span><span class="p">,</span>
                          <span class="n">element_phase_map</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

<span class="c1"># The polycrystal may be saved to disc for later usage.</span>
<span class="n">polycrystal</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;my_polycrystal&#39;</span><span class="p">,</span> <span class="n">save_mesh_as_xdmf</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">polycrystal_loaded_from_disc</span> <span class="o">=</span> <span class="n">Polycrystal</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;my_polycrystal.pc&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
<p>Below follows a detailed description of the polycrystal class attributes and functions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="xrd_simulator.polycrystal.Polycrystal">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xrd_simulator.polycrystal.</span></span><span class="sig-name descname"><span class="pre">Polycrystal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phases</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">element_phase_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/polycrystal.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.polycrystal.Polycrystal" title="Permalink to this definition"></a></dt>
<dd><p>Represents a multi-phase polycrystal as a tetrahedral mesh where each element can be a single crystal</p>
<p>The polycrystal is created in laboratory coordinates. At instantiation it is assumed that the sample and
lab coordinate systems are aligned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#xrd_simulator.mesh.TetraMesh" title="xrd_simulator.mesh.TetraMesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.mesh.TetraMesh</span></code></a>) – Object representing a tetrahedral mesh which defines the
geometry of the sample. (At instantiation it is assumed that the sample and lab coordinate systems
are aligned.)</p></li>
<li><p><strong>orientation</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Per element orientation matrices (sometimes known by the capital letter U),
(<code class="docutils literal notranslate"><span class="pre">shape=(N,3,3)</span></code>) or (<code class="docutils literal notranslate"><span class="pre">shape=(3,3)</span></code>) if the orientation is the same for all elements. The orientation
matrix maps from crystal coordinates to sample coordinates.</p></li>
<li><p><strong>strain</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Per element strain tensor, in lab coordinates, (<code class="docutils literal notranslate"><span class="pre">shape=(N,3,3)</span></code>) or (<code class="docutils literal notranslate"><span class="pre">shape=(3,3)</span></code>)
if the strain is the same for all elements elements.</p></li>
<li><p><strong>phases</strong> (<a class="reference internal" href="#xrd_simulator.phase.Phase" title="xrd_simulator.phase.Phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.phase.Phase</span></code></a> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#xrd_simulator.phase.Phase" title="xrd_simulator.phase.Phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.phase.Phase</span></code></a>) – Phase of the
polycrystal, or for multiphase samples, a list of all phases present in the polycrystal.</p></li>
<li><p><strong>element_phase_map</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Index of phase that elements belong to such that phases[element_phase_map[i]]
gives the xrd_simulator.phase.Phase object of element number i. None if the sample is composed of a single phase.
(Defaults to None)</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.polycrystal.Polycrystal.mesh_lab">
<span class="sig-name descname"><span class="pre">mesh_lab</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/polycrystal.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.polycrystal.Polycrystal.mesh_lab" title="Permalink to this definition"></a></dt>
<dd><p>Object representing a tetrahedral mesh which defines the
geometry of the sample in a fixed lab frame coordinate system. This quantity is updated when the sample transforms.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#xrd_simulator.mesh.TetraMesh" title="xrd_simulator.mesh.TetraMesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.mesh.TetraMesh</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.polycrystal.Polycrystal.mesh_sample">
<span class="sig-name descname"><span class="pre">mesh_sample</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/polycrystal.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.polycrystal.Polycrystal.mesh_sample" title="Permalink to this definition"></a></dt>
<dd><p>Object representing a tetrahedral mesh which defines the
geometry of the sample in a sample coordinate system. This quantity is not updated when the sample transforms.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#xrd_simulator.mesh.TetraMesh" title="xrd_simulator.mesh.TetraMesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.mesh.TetraMesh</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.polycrystal.Polycrystal.orientation_lab">
<span class="sig-name descname"><span class="pre">orientation_lab</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/polycrystal.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.polycrystal.Polycrystal.orientation_lab" title="Permalink to this definition"></a></dt>
<dd><p>Per element orientation matrices mapping from the crystal to the lab coordinate
system, this quantity is updated when the sample transforms. (<code class="docutils literal notranslate"><span class="pre">shape=(N,3,3)</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.polycrystal.Polycrystal.orientation_sample">
<span class="sig-name descname"><span class="pre">orientation_sample</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/polycrystal.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.polycrystal.Polycrystal.orientation_sample" title="Permalink to this definition"></a></dt>
<dd><p>Per element orientation matrices mapping from the crystal to the sample
coordinate system.,  this quantity is not updated when the sample transforms. (<code class="docutils literal notranslate"><span class="pre">shape=(N,3,3)</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.polycrystal.Polycrystal.strain_lab">
<span class="sig-name descname"><span class="pre">strain_lab</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/polycrystal.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.polycrystal.Polycrystal.strain_lab" title="Permalink to this definition"></a></dt>
<dd><p>Per element strain tensor in a fixed lab frame coordinate
system, this quantity is updated when the sample transforms. (<code class="docutils literal notranslate"><span class="pre">shape=(N,3,3)</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.polycrystal.Polycrystal.strain_sample">
<span class="sig-name descname"><span class="pre">strain_sample</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/polycrystal.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.polycrystal.Polycrystal.strain_sample" title="Permalink to this definition"></a></dt>
<dd><p>Per element strain tensor in a sample coordinate
system., this quantity is not updated when the sample transforms. (<code class="docutils literal notranslate"><span class="pre">shape=(N,3,3)</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.polycrystal.Polycrystal.phases">
<span class="sig-name descname"><span class="pre">phases</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/polycrystal.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.polycrystal.Polycrystal.phases" title="Permalink to this definition"></a></dt>
<dd><p>List of all unique phases present in the polycrystal.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <a class="reference internal" href="#xrd_simulator.phase.Phase" title="xrd_simulator.phase.Phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.phase.Phase</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.polycrystal.Polycrystal.element_phase_map">
<span class="sig-name descname"><span class="pre">element_phase_map</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/polycrystal.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.polycrystal.Polycrystal.element_phase_map" title="Permalink to this definition"></a></dt>
<dd><p>Index of phase that elements belong to such that phases[element_phase_map[i]]
gives the xrd_simulator.phase.Phase object of element number i.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.polycrystal.Polycrystal.diffract">
<span class="sig-name descname"><span class="pre">diffract</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">detector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rigid_body_motion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_bragg_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_bragg_angle</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/polycrystal.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.polycrystal.Polycrystal.diffract" title="Permalink to this definition"></a></dt>
<dd><p>Compute diffraction from the rotating and translating polycrystal while illuminated by an xray beam.</p>
<p>The xray beam interacts with the polycrystal producing scattering units which are stored in a detector frame.
The scattering units may be rendered as pixelated patterns on the detector by using a detector rendering
option.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>beam</strong> (<a class="reference internal" href="#xrd_simulator.beam.Beam" title="xrd_simulator.beam.Beam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.beam.Beam</span></code></a>) – Object representing a monochromatic beam of xrays.</p></li>
<li><p><strong>detector</strong> (<a class="reference internal" href="#xrd_simulator.detector.Detector" title="xrd_simulator.detector.Detector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.detector.Detector</span></code></a>) – Object representing a flat rectangular detector.</p></li>
<li><p><strong>rigid_body_motion</strong> (<a class="reference internal" href="#xrd_simulator.motion.RigidBodyMotion" title="xrd_simulator.motion.RigidBodyMotion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.motion.RigidBodyMotion</span></code></a>) – Rigid body motion object describing the
polycrystal transformation as a function of time on the domain (time=[0,1]) over which diffraction is to be
computed.</p></li>
<li><p><strong>min_bragg_angle</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Minimum Bragg angle (radians) below which to not compute diffraction.
Defaults to 0.</p></li>
<li><p><strong>max_bragg_angle</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Maximum Bragg angle (radians) after which to not compute diffraction. By default
the max_bragg_angle is approximated by wrapping the detector corners in a cone with apex at the sample
centroid.</p></li>
<li><p><strong>verbose</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>) – Prints progress. Defaults to True.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.polycrystal.Polycrystal.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rigid_body_motion</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/polycrystal.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.polycrystal.Polycrystal.transform" title="Permalink to this definition"></a></dt>
<dd><p>Transform the polycrystal by performing a rigid body motion (translation + rotation)</p>
<p>This function will update the polycrystal mesh (update in lab frame) with any dependent quantities,
such as face normals etc. Likewise, it will update the per element crystal orientation
matrices (U) as well as the lab frame description of strain tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rigid_body_motion</strong> (<a class="reference internal" href="#xrd_simulator.motion.RigidBodyMotion" title="xrd_simulator.motion.RigidBodyMotion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.motion.RigidBodyMotion</span></code></a>) – Rigid body motion object describing the
polycrystal transformation as a function of time on the domain time=[0,1].</p></li>
<li><p><strong>time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Time between [0,1] at which to call the rigid body motion.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.polycrystal.Polycrystal.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_mesh_as_xdmf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/polycrystal.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.polycrystal.Polycrystal.save" title="Permalink to this definition"></a></dt>
<dd><p>Save polycrystal to disc (via pickling).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – File path at which to save, ending with the desired filename.</p></li>
<li><p><strong>save_mesh_as_xdmf</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>) – If true, saves the polycyrystal mesh with associated
strains and crystal orientations as a .xdmf for visualization (sample coordinates).
The results can be vizualised with for instance paraview (<a class="reference external" href="https://www.paraview.org/">https://www.paraview.org/</a>).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.polycrystal.Polycrystal.load">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/polycrystal.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.polycrystal.Polycrystal.load" title="Permalink to this definition"></a></dt>
<dd><p>Load polycrystal from disc (via pickling).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – File path at which to load, ending with the desired filename.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function will unpickle data from the provied path. The pickle module
is not intended to be secure against erroneous or maliciously constructed data.
Never unpickle data received from an untrusted or unauthenticated source.</p>
</aside>
</dd></dl>

</dd></dl>

</section>
<section id="module-xrd_simulator.mesh">
<span id="mesh"></span><h2>mesh<a class="headerlink" href="#module-xrd_simulator.mesh" title="Permalink to this headline"></a></h2>
<p>The mesh module is used to represent the morphology of a polycrystalline sample.
Once created and linked to a polycrystal the mesh can be accessed directly through
the <a class="reference internal" href="#xrd_simulator.polycrystal.Polycrystal" title="xrd_simulator.polycrystal.Polycrystal"><code class="xref py py-class docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal.Polycrystal</span></code></a>. Here is a minimal example of how
to instantiate a mesh and save it to disc:</p>
<blockquote>
<div><dl>
<dt>Examples:</dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">xrd_simulator.mesh</span> <span class="kn">import</span> <span class="n">TetraMesh</span>

<span class="c1"># Generate mesh with 2 elements from nodal coordinates.</span>
<span class="n">nodal_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
<span class="n">element_node_map</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">TetraMesh</span><span class="o">.</span><span class="n">generate_mesh_from_vertices</span><span class="p">(</span><span class="n">nodal_coordinates</span><span class="p">,</span> <span class="n">element_node_map</span><span class="p">)</span>

<span class="c1"># The mesh may be saved to disc for later usage or visualization.</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;my_mesh&#39;</span><span class="p">)</span>
<span class="n">mesh_loaded_from_disc</span> <span class="o">=</span> <span class="n">TetraMesh</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;my_mesh.xdmf&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
<p>This should look somethign like this in a 3D viewer like paraview:</p>
<a class="reference internal image-reference" href="https://github.com/FABLE-3DXRD/xrd_simulator/blob/main/docs/source/images/mesh_example.png?raw=true"><img alt="https://github.com/FABLE-3DXRD/xrd_simulator/blob/main/docs/source/images/mesh_example.png?raw=true" class="align-center" src="https://github.com/FABLE-3DXRD/xrd_simulator/blob/main/docs/source/images/mesh_example.png?raw=true" style="width: 300px;" /></a>
<p>Below follows a detailed description of the mesh class attributes and functions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xrd_simulator.mesh.</span></span><span class="sig-name descname"><span class="pre">TetraMesh</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh" title="Permalink to this definition"></a></dt>
<dd><p>Defines a 3D tetrahedral mesh with associated geometry data such face normals, centroids, etc.</p>
<p>For level-set mesh generation the TetraMesh uses <a class="reference external" href="https://github.com/nschloe/meshio">the meshio package</a>: For more meshing tools
please see this package directly (which itself is a wrapper of CGAL)</p>
<blockquote>
<div></div></blockquote>
<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.coord">
<span class="sig-name descname"><span class="pre">coord</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.coord" title="Permalink to this definition"></a></dt>
<dd><p>Nodal coordinates, shape=(nenodes, 3). Each row in coord defines the
coordinates of a mesh node.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.enod">
<span class="sig-name descname"><span class="pre">enod</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.enod" title="Permalink to this definition"></a></dt>
<dd><p>Tetra element nodes shape=(nelm, nenodes).e.g enod[i,:] gives
the nodal indices of element i.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.dof">
<span class="sig-name descname"><span class="pre">dof</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.dof" title="Permalink to this definition"></a></dt>
<dd><p>Per node degrees of freedom, i.e dof[i,:]
gives the degrees of freedom of node i.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.efaces">
<span class="sig-name descname"><span class="pre">efaces</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.efaces" title="Permalink to this definition"></a></dt>
<dd><p>Element faces nodal indices, shape=(nelm, nenodes, 3).
e.g efaces[i,j,:] gives the nodal indices of face j of element i.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.enormals">
<span class="sig-name descname"><span class="pre">enormals</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.enormals" title="Permalink to this definition"></a></dt>
<dd><p>Element faces outwards normals (nelm, nefaces, 3).
e.g enormals[i,j,:] gives the normal of face j of element i.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.ecentroids">
<span class="sig-name descname"><span class="pre">ecentroids</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.ecentroids" title="Permalink to this definition"></a></dt>
<dd><p>Per element centroids, shape=(nelm, 3).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.eradius">
<span class="sig-name descname"><span class="pre">eradius</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.eradius" title="Permalink to this definition"></a></dt>
<dd><p>Per element bounding ball radius, shape=(nelm, 1).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.espherecentroids">
<span class="sig-name descname"><span class="pre">espherecentroids</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.espherecentroids" title="Permalink to this definition"></a></dt>
<dd><p>Per element bounding ball centroids, shape=(nelm, 3).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.evolumes">
<span class="sig-name descname"><span class="pre">evolumes</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.evolumes" title="Permalink to this definition"></a></dt>
<dd><p>Per element volume, shape=(nelm,).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.centroid">
<span class="sig-name descname"><span class="pre">centroid</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.centroid" title="Permalink to this definition"></a></dt>
<dd><p>Global centroid of the entire mesh, shape=(3,)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.number_of_elements">
<span class="sig-name descname"><span class="pre">number_of_elements</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.number_of_elements" title="Permalink to this definition"></a></dt>
<dd><p>Number of tetrahedral elements in the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.generate_mesh_from_vertices">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generate_mesh_from_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coord</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">enod</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.generate_mesh_from_vertices" title="Permalink to this definition"></a></dt>
<dd><p>Generate a mesh from vertices using <a class="reference external" href="https://github.com/nschloe/meshio">the meshio package</a>:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>coord</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Nodal coordinates, shape=(nenodes, 3). Each row in coord defines the
coordinates of a mesh node.</p></li>
<li><p><strong>enod</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Tetra element nodes shape=(nelm, nenodes).e.g enod[i,:] gives
the nodal indices of element i.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.generate_mesh_from_levelset">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generate_mesh_from_levelset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">level_set</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bounding_radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_cell_circumradius</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.generate_mesh_from_levelset" title="Permalink to this definition"></a></dt>
<dd><p>Generate a mesh from a level set using <a class="reference external" href="https://github.com/nschloe/pygalmesh">the pygalmesh package</a>:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>level_set</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code>) – Level set, level_set(x) should give a negative output on the exterior
of the mesh and positive on the interior.</p></li>
<li><p><strong>bounding_radius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Bounding radius of mesh.</p></li>
<li><p><strong>max_cell_circumradius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Bound for element radii.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_nodal_coordinates</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.update" title="Permalink to this definition"></a></dt>
<dd><p>Update the mesh coordinates and any dependent quantities by changing the node coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>new_nodal_coordinates</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – new coordinates of mesh nodes.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">element_data</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.save" title="Permalink to this definition"></a></dt>
<dd><p>Save the tetra mesh to .xdmf paraview readable format for visualization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Absolute path to save the mesh in .xdmf format.</p></li>
<li><p><strong>element_data</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Data associated to the elements.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.mesh.TetraMesh.load">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/mesh.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.mesh.TetraMesh.load" title="Permalink to this definition"></a></dt>
<dd><p>Load a mesh from a saved mesh file set using <a class="reference external" href="https://github.com/nschloe/meshio">the meshio package</a>:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Absolute path to the mesh file.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-xrd_simulator.phase">
<span id="phase"></span><h2>phase<a class="headerlink" href="#module-xrd_simulator.phase" title="Permalink to this headline"></a></h2>
<p>The phase module is used to represent material phase. Each element of the
<a class="reference internal" href="#xrd_simulator.polycrystal.Polycrystal" title="xrd_simulator.polycrystal.Polycrystal"><code class="xref py py-class docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal.Polycrystal</span></code></a> mesh is linked to a <a class="reference internal" href="#xrd_simulator.phase.Phase" title="xrd_simulator.phase.Phase"><code class="xref py py-class docutils literal notranslate"><span class="pre">xrd_simulator.phase.Phase</span></code></a>
describing things like the lattice reference unit cell and generating Miller indices of scattering planes.
By providing a crystalographic information file (.cif) structure factors can be computed.</p>
<p>Here is a minimal example of how to instantiate a Phase object</p>
<blockquote>
<div><dl>
<dt>Examples:</dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">xrd_simulator.phase</span> <span class="kn">import</span> <span class="n">Phase</span>

<span class="c1"># The phase can be specified via a crystalographic information file.</span>
<span class="n">quartz</span> <span class="o">=</span> <span class="n">Phase</span><span class="p">(</span><span class="n">unit_cell</span><span class="o">=</span><span class="p">[</span><span class="mf">4.926</span><span class="p">,</span> <span class="mf">4.926</span><span class="p">,</span> <span class="mf">5.4189</span><span class="p">,</span> <span class="mf">90.</span><span class="p">,</span> <span class="mf">90.</span><span class="p">,</span> <span class="mf">120.</span><span class="p">],</span>
               <span class="n">sgname</span><span class="o">=</span><span class="s1">&#39;P3221&#39;</span><span class="p">,</span>
               <span class="n">path_to_cif_file</span><span class="o">=</span><span class="s1">&#39;quartz.cif&#39;</span>
               <span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
<p><a class="reference external" href="https://github.com/FABLE-3DXRD/xrd_simulator/blob/main/docs/source/examples/quartz.cif?raw=true">The .cif file used in the above example can be found here.</a></p>
<p>Below follows a detailed description of the Phase class attributes and functions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="xrd_simulator.phase.Phase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xrd_simulator.phase.</span></span><span class="sig-name descname"><span class="pre">Phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">unit_cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sgname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_to_cif_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/phase.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.phase.Phase" title="Permalink to this definition"></a></dt>
<dd><p>Defines properties related to a crystal class.</p>
<p>The barebone Phase object holds the space group name and unit cell of the crystal. From this it is possible
to compute a set of Miller indices for a given wavelength that can give diffraction. In addition, it is
possible to compute unit cell structure factors for the hkls which is usefull to model the scattered intensity.
This will however require a CIF file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>unit_cell</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Crystal unit cell representation of the form
[a,b,c,alpha,beta,gamma], where alpha,beta and gamma are in units of degrees while
a,b and c are in units of anstrom.</p></li>
<li><p><strong>sgname</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>) – Name of space group , e.g ‘P3221’ for quartz, SiO2, for instance</p></li>
<li><p><strong>path_to_cif_file</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>) – Path to CIF file. Defaults to None, in which case no structure
factors are computed, i.e <cite>structure_factors=None</cite>.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.phase.Phase.unit_cell">
<span class="sig-name descname"><span class="pre">unit_cell</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/phase.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.phase.Phase.unit_cell" title="Permalink to this definition"></a></dt>
<dd><p>Crystal unit cell representation of the form
[a,b,c,alpha,beta,gamma], where alpha,beta and gamma are in units of degrees while
a,b and c are in units of anstrom.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.phase.Phase.sgname">
<span class="sig-name descname"><span class="pre">sgname</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/phase.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.phase.Phase.sgname" title="Permalink to this definition"></a></dt>
<dd><p>Name of space group , e.g ‘P3221’ for quartz, SiO2, for instance</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.phase.Phase.miller_indices">
<span class="sig-name descname"><span class="pre">miller_indices</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/phase.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.phase.Phase.miller_indices" title="Permalink to this definition"></a></dt>
<dd><p>Allowable integer Miller indices (h,k,l) of <code class="docutils literal notranslate"><span class="pre">shape=(n,3)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.phase.Phase.structure_factors">
<span class="sig-name descname"><span class="pre">structure_factors</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/phase.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.phase.Phase.structure_factors" title="Permalink to this definition"></a></dt>
<dd><p>Structure factors of allowable Miller indices (<code class="docutils literal notranslate"><span class="pre">`miller_indices`</span></code>)
of <code class="docutils literal notranslate"><span class="pre">shape=(n,2)</span></code>. <cite>structure_factors[i,0]</cite> gives the real structure factor of <cite>hkl=miller_indices[i,:]</cite>
while <cite>structure_factors[i,0]</cite> gives the corresponding imaginary part of the structure factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.phase.Phase.path_to_cif_file">
<span class="sig-name descname"><span class="pre">path_to_cif_file</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/phase.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.phase.Phase.path_to_cif_file" title="Permalink to this definition"></a></dt>
<dd><p>Path to CIF file.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.phase.Phase.setup_diffracting_planes">
<span class="sig-name descname"><span class="pre">setup_diffracting_planes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_bragg_angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_bragg_angle</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/phase.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.phase.Phase.setup_diffracting_planes" title="Permalink to this definition"></a></dt>
<dd><p>Generates all Miller indices (h,k,l) that will diffract given wavelength and Bragg angle bounds.</p>
<p>If self.path_to_cif_file is not None, structure factors are computed in addition to the hkls.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>wavelength</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – xray wavelength in units of anstrom.</p></li>
<li><p><strong>min_bragg_angle</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Maximum Bragg angle, in radians, allowed to be taken during diffraction.</p></li>
<li><p><strong>max_bragg_angle</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Minimum Bragg angle, in radians, allowed to be taken during diffraction.</p></li>
</ul>
</dd>
</dl>
<p>NOTE: This function will skip Miller indices that have a zero intensity due to the unit cell structure
factor vanishing, i.e forbidden reflections, such as a 100 in an fcc for instance, will not be included.</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-xrd_simulator.beam">
<span id="beam"></span><h2>beam<a class="headerlink" href="#module-xrd_simulator.beam" title="Permalink to this headline"></a></h2>
<p>The beam module is used to represent a beam of xrays. The idea is to create a <a class="reference internal" href="#xrd_simulator.beam.Beam" title="xrd_simulator.beam.Beam"><code class="xref py py-class docutils literal notranslate"><span class="pre">xrd_simulator.beam.Beam</span></code></a> object and
pass it along to the <a class="reference internal" href="#xrd_simulator.polycrystal.Polycrystal.diffract" title="xrd_simulator.polycrystal.Polycrystal.diffract"><code class="xref py py-func docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal.Polycrystal.diffract()</span></code></a> function to compute diffraction from the sample
for the specified xray beam geometry. Here is a minimal example of how to instantiate a beam object and save it to disc:</p>
<blockquote>
<div><dl>
<dt>Examples:</dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">xrd_simulator.beam</span> <span class="kn">import</span> <span class="n">Beam</span>

<span class="c1"># The beam of xrays is represented as a convex polyhedron</span>
<span class="c1"># We specify the vertices in a numpy array.</span>
<span class="n">beam_vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
    <span class="p">[</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
    <span class="p">[</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
    <span class="p">[</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span>
    <span class="p">[</span><span class="o">-</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">],</span>
    <span class="p">[</span><span class="mf">5.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]])</span>

<span class="c1"># The xray beam object is instantiated</span>
<span class="n">beam</span> <span class="o">=</span> <span class="n">Beam</span><span class="p">(</span>
    <span class="n">beam_vertices</span><span class="p">,</span>
    <span class="n">xray_propagation_direction</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]),</span>
    <span class="n">wavelength</span><span class="o">=</span><span class="mf">0.28523</span><span class="p">,</span>
    <span class="n">polarization_vector</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]))</span>

<span class="c1"># The xray beam may be saved to disc for later usage.</span>
<span class="n">beam</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;my_xray_beam&#39;</span><span class="p">)</span>
<span class="n">beam_loaded_from_disc</span> <span class="o">=</span> <span class="n">Beam</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;my_xray_beam.beam&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
<p>Below follows a detailed description of the beam class attributes and functions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="xrd_simulator.beam.Beam">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xrd_simulator.beam.</span></span><span class="sig-name descname"><span class="pre">Beam</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beam_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xray_propagation_direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polarization_vector</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/beam.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.beam.Beam" title="Permalink to this definition"></a></dt>
<dd><p>Represents a monochromatic xray beam as a convex polyhedra with uniform intensity.</p>
<p>The beam is described in the laboratory coordinate system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>beam_vertices</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Vertices of the xray beam in units of microns, <code class="docutils literal notranslate"><span class="pre">shape=(N,3)</span></code>.</p></li>
<li><p><strong>xray_propagation_direction</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Propagation direction of xrays, <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code>.</p></li>
<li><p><strong>wavelength</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Xray wavelength in units of angstrom.</p></li>
<li><p><strong>polarization_vector</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Beam linear polarization unit vector <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code>.
Must be orthogonal to the xray propagation direction.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.beam.Beam.vertices">
<span class="sig-name descname"><span class="pre">vertices</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/beam.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.beam.Beam.vertices" title="Permalink to this definition"></a></dt>
<dd><p>Vertices of the xray beam in units of microns, <code class="docutils literal notranslate"><span class="pre">shape=(N,3)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.beam.Beam.wavelength">
<span class="sig-name descname"><span class="pre">wavelength</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/beam.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.beam.Beam.wavelength" title="Permalink to this definition"></a></dt>
<dd><p>Xray wavelength in units of angstrom.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.beam.Beam.wave_vector">
<span class="sig-name descname"><span class="pre">wave_vector</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/beam.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.beam.Beam.wave_vector" title="Permalink to this definition"></a></dt>
<dd><p>Beam wavevector with norm 2*pi/wavelength, <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.beam.Beam.polarization_vector">
<span class="sig-name descname"><span class="pre">polarization_vector</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/beam.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.beam.Beam.polarization_vector" title="Permalink to this definition"></a></dt>
<dd><p>Beam linear polarization unit vector <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code>.
Must be orthogonal to the xray propagation direction.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.beam.Beam.centroid">
<span class="sig-name descname"><span class="pre">centroid</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/beam.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.beam.Beam.centroid" title="Permalink to this definition"></a></dt>
<dd><p>Beam convex hull centroid <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.beam.Beam.halfspaces">
<span class="sig-name descname"><span class="pre">halfspaces</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/beam.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.beam.Beam.halfspaces" title="Permalink to this definition"></a></dt>
<dd><p>Beam halfspace equation coefficients <code class="docutils literal notranslate"><span class="pre">shape=(N,3)</span></code>.
A point x is on the interior of the halfspace if: halfspaces[i,:-1].dot(x) +  halfspaces[i,-1] &lt;= 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.beam.Beam.set_beam_vertices">
<span class="sig-name descname"><span class="pre">set_beam_vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">beam_vertices</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/beam.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.beam.Beam.set_beam_vertices" title="Permalink to this definition"></a></dt>
<dd><p>Set the beam vertices defining the beam convex hull and update all dependent quantities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>beam_vertices</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Vertices of the xray beam in units of microns, <code class="docutils literal notranslate"><span class="pre">shape=(N,3)</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.beam.Beam.contains">
<span class="sig-name descname"><span class="pre">contains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/beam.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.beam.Beam.contains" title="Permalink to this definition"></a></dt>
<dd><p>Check if the beam contains a point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>point</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Point to evaluate <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Boolean True if the beam contains the point.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.beam.Beam.intersect">
<span class="sig-name descname"><span class="pre">intersect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/beam.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.beam.Beam.intersect" title="Permalink to this definition"></a></dt>
<dd><p>Compute the beam intersection with a convex polyhedra.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>vertices</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Vertices of a convex polyhedra with <code class="docutils literal notranslate"><span class="pre">shape=(N,3)</span></code>.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.spatial.ConvexHull</span></code> object formed from the vertices of the intersection between beam vertices and
input vertices.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.beam.Beam.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/beam.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.beam.Beam.save" title="Permalink to this definition"></a></dt>
<dd><p>Save the xray beam to disc (via pickling).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – File path at which to save, ending with the desired filename.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.beam.Beam.load">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/beam.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.beam.Beam.load" title="Permalink to this definition"></a></dt>
<dd><p>Load the xray beam from disc (via pickling).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – File path at which to load, ending with the desired filename.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function will unpickle data from the provied path. The pickle module
is not intended to be secure against erroneous or maliciously constructed data.
Never unpickle data received from an untrusted or unauthenticated source.</p>
</aside>
</dd></dl>

</dd></dl>

</section>
<section id="module-xrd_simulator.detector">
<span id="detector"></span><h2>detector<a class="headerlink" href="#module-xrd_simulator.detector" title="Permalink to this headline"></a></h2>
<p>The detector module is used to represent a 2D area detector. After diffraction from a
<a class="reference internal" href="#xrd_simulator.polycrystal.Polycrystal" title="xrd_simulator.polycrystal.Polycrystal"><code class="xref py py-class docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal.Polycrystal</span></code></a> has been computed, the detector can render
the scattering as a pixelated image via the <a class="reference internal" href="#xrd_simulator.detector.Detector.render" title="xrd_simulator.detector.Detector.render"><code class="xref py py-func docutils literal notranslate"><span class="pre">xrd_simulator.detector.Detector.render()</span></code></a>
function.</p>
<p>Here is a minimal example of how to instantiate a detector object and save it to disc:</p>
<blockquote>
<div><dl>
<dt>Examples:</dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">xrd_simulator.detector</span> <span class="kn">import</span> <span class="n">Detector</span>

<span class="c1"># The detector is defined by it&#39;s corner coordinates det_corner_0, det_corner_1, det_corner_2</span>
<span class="n">detector</span> <span class="o">=</span> <span class="n">Detector</span><span class="p">(</span><span class="n">pixel_size_z</span><span class="o">=</span><span class="mf">75.0</span><span class="p">,</span>
                    <span class="n">pixel_size_y</span><span class="o">=</span><span class="mf">55.0</span><span class="p">,</span>
                    <span class="n">det_corner_0</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">142938.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">38400.</span><span class="p">,</span> <span class="o">-</span><span class="mf">38400.</span><span class="p">]),</span>
                    <span class="n">det_corner_1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">142938.3</span><span class="p">,</span> <span class="mf">38400.</span><span class="p">,</span> <span class="o">-</span><span class="mf">38400.</span><span class="p">]),</span>
                    <span class="n">det_corner_2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">142938.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">38400.</span><span class="p">,</span> <span class="mf">38400.</span><span class="p">]))</span>

<span class="c1"># The detector may be saved to disc for later usage.</span>
<span class="n">detector</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;my_detector&#39;</span><span class="p">)</span>
<span class="n">detector_loaded_from_disc</span> <span class="o">=</span> <span class="n">Detector</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;my_detector.det&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
<p>Below follows a detailed description of the detector class attributes and functions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xrd_simulator.detector.</span></span><span class="sig-name descname"><span class="pre">Detector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pixel_size_z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pixel_size_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">det_corner_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">det_corner_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">det_corner_2</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector" title="Permalink to this definition"></a></dt>
<dd><p>Represents a rectangular 2D area detector.</p>
<p>The detector collects <a class="reference internal" href="#xrd_simulator.scattering_unit.ScatteringUnit" title="xrd_simulator.scattering_unit.ScatteringUnit"><code class="xref py py-class docutils literal notranslate"><span class="pre">xrd_simulator.scattering_unit.ScatteringUnit</span></code></a> during diffraction from a
<a class="reference internal" href="#xrd_simulator.polycrystal.Polycrystal" title="xrd_simulator.polycrystal.Polycrystal"><code class="xref py py-class docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal.Polycrystal</span></code></a>. The detector implements various rendering of the scattering
as 2D pixelated images. The detector geometry is described by specifying the locations of three detector
corners. The detector is described in the laboratory coordinate system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pixel_size_z</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Pixel side length along zdhat (rectangular pixels) in units of microns.
(zdhat is the unit vector from det_corner_0 towards det_corner_2)</p></li>
<li><p><strong>pixel_size_y</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Pixel side length along ydhat (rectangular pixels) in units of microns.
(ydhat is the unit vector from det_corner_0 towards det_corner_1)</p></li>
<li><p><strong>det_corner_0</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Detector corner 3d coordinates <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code>.
The origin of the detector is at det_corner_0.</p></li>
<li><p><strong>det_corner_1</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Detector corner 3d coordinates <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code>.
The origin of the detector is at det_corner_0.</p></li>
<li><p><strong>det_corner_2</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Detector corner 3d coordinates <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code>.
The origin of the detector is at det_corner_0.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector.pixel_size_z">
<span class="sig-name descname"><span class="pre">pixel_size_z</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector.pixel_size_z" title="Permalink to this definition"></a></dt>
<dd><p>Pixel side length along zdhat (rectangular pixels) in units of microns.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector.pixel_size_y">
<span class="sig-name descname"><span class="pre">pixel_size_y</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector.pixel_size_y" title="Permalink to this definition"></a></dt>
<dd><p>Pixel side length along ydhat (rectangular pixels) in units of microns.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">det_corner_0,det_corner_1,det_corner_2</span></span></dt>
<dd><p>Detector corner 3d coordinates <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code>.
The origin of the detector is at det_corner_0.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector.frames">
<span class="sig-name descname"><span class="pre">frames</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector.frames" title="Permalink to this definition"></a></dt>
<dd><p>Analytical diffraction patterns which</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">scattering_unit.ScatteringUnit</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">zdhat,ydhat</span></span></dt>
<dd><p>Detector basis vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector.normal">
<span class="sig-name descname"><span class="pre">normal</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector.normal" title="Permalink to this definition"></a></dt>
<dd><p>Detector normal, fromed as the cross product: numpy.cross(self.zdhat, self.ydhat)</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">zmax,ymax</span></span></dt>
<dd><p>Detector width and height.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector.pixel_coordinates">
<span class="sig-name descname"><span class="pre">pixel_coordinates</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector.pixel_coordinates" title="Permalink to this definition"></a></dt>
<dd><p>Real space 3d detector pixel coordinates. <code class="docutils literal notranslate"><span class="pre">shape=(n,3)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector.point_spread_function">
<span class="sig-name descname"><span class="pre">point_spread_function</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector.point_spread_function" title="Permalink to this definition"></a></dt>
<dd><p>Scalar point spread function called as point_spread_function(z, y). The
z and y coordinates are assumed to be in local units of pixels. I.e point_spread_function(0, 0) returns the
value of the pointspread function at the location of the point being spread. This is meant to model blurring
due to detector optics. Defaults to a Gaussian with standard deviation 1.0 and mean at (z,y)=(0,0).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector.point_spread_kernel_shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">point_spread_kernel_shape</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector.point_spread_kernel_shape" title="Permalink to this definition"></a></dt>
<dd><p>Number of pixels in zdhat and ydhat over which to apply the pointspread
function for each scattering event. I.e the shape of the kernel that will be convolved with the diffraction
pattern. The values of the kernel is defined by the point_spread_function. Defaults to shape (5, 5).</p>
<dl class="simple">
<dt>NOTE: The point_spread_function is automatically normalised over the point_spread_kernel_shape domain such that the</dt><dd><p>final convolution over the detector diffraction pattern is intensity preserving.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>point_spread_kernel_shape  (<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector.render">
<span class="sig-name descname"><span class="pre">render</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame_number</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lorentz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">polarization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">structure_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'centroid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector.render" title="Permalink to this definition"></a></dt>
<dd><p>Render a pixelated diffraction pattern onto the detector plane .</p>
<p>NOTE: The value read out on a pixel in the detector is an approximation of the integrated number of counts over
the pixel area.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame_number</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Index of the frame in the <a class="reference internal" href="#xrd_simulator.detector.Detector.frames" title="xrd_simulator.detector.Detector.frames"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frames</span></code></a> list to be rendered.</p></li>
<li><p><strong>lorentz</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>) – Weight scattered intensity by Lorentz factor. Defaults to False.</p></li>
<li><p><strong>polarization</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>) – Weight scattered intensity by Polarization factor. Defaults to False.</p></li>
<li><p><strong>structure_factor</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>) – Weight scattered intensity by Structure Factor factor. Defaults to False.</p></li>
<li><p><strong>method</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – Rendering method, must be one of <code class="docutils literal notranslate"><span class="pre">`project`</span></code> or <code class="docutils literal notranslate"><span class="pre">`centroid`</span></code>. Defaults to <code class="docutils literal notranslate"><span class="pre">`centroid`</span></code>.
The default,```method=centroid```, is a simple deposit of intensity for each scattering_unit onto the detector by
tracing a line from the sample scattering region centroid to the detector plane. The intensity is deposited
into a single detector pixel regardless of the geometrical shape of the scattering_unit. If instead
<code class="docutils literal notranslate"><span class="pre">`method=project`</span></code> the scattering regions are projected onto the detector depositing a intensity over
possibly several pixels as weighted by the optical path lengths of the rays diffracting from the scattering
region.</p></li>
<li><p><strong>verbose</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">bool</span></code>) – Prints progress. Defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A pixelated frame as a (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) with shape inferred form the detector geometry and
pixel size.</p>
</dd>
</dl>
<p>NOTE: This function can be overwitten to do more advanced models for intensity.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector.get_intersection">
<span class="sig-name descname"><span class="pre">get_intersection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ray_direction</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_point</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector.get_intersection" title="Permalink to this definition"></a></dt>
<dd><p>Get detector intersection in detector coordinates of a single ray originating from source_point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ray_direction</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Vector in direction of the xray propagation</p></li>
<li><p><strong>source_point</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Origin of the ray.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code>) zd, yd in detector plane coordinates.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector.contains">
<span class="sig-name descname"><span class="pre">contains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zd</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">yd</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector.contains" title="Permalink to this definition"></a></dt>
<dd><p>Determine if the detector coordinate zd,yd lies within the detector bounds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zd</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Detector z coordinate</p></li>
<li><p><strong>yd</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Detector y coordinate</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(<code class="xref py py-obj docutils literal notranslate"><span class="pre">boolean</span></code>) True if the zd,yd is within the detector bounds.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector.project">
<span class="sig-name descname"><span class="pre">project</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scattering_unit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">box</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector.project" title="Permalink to this definition"></a></dt>
<dd><p>Compute parametric projection of scattering region unto detector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scattering_unit</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.ScatteringUnit</span></code>) – The scattering region.</p></li>
<li><p><strong>box</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – indices of the detector frame over which to compute the projection.
i.e the subgrid of the detector is taken as: array[[box[0]:box[1], box[2]:box[3]].</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) clip lengths between scattering_unit polyhedron and rays traced from the detector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector.get_wrapping_cone">
<span class="sig-name descname"><span class="pre">get_wrapping_cone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_point</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector.get_wrapping_cone" title="Permalink to this definition"></a></dt>
<dd><p>Compute the cone around a wavevector such that the cone wraps the detector corners.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Wavevector forming the central axis of cone <code class="docutils literal notranslate"><span class="pre">`shape=(3,)`</span></code>.</p></li>
<li><p><strong>source_point</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Origin of the wavevector <code class="docutils literal notranslate"><span class="pre">`shape=(3,)`</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>(<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) Cone opening angle divided by two (radians), corresponding to a maximum bragg angle after</dt><dd><p>which scattering will systematically miss the detector.</p>
</dd>
</dl>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector.save" title="Permalink to this definition"></a></dt>
<dd><p>Save the detector object to disc (via pickling).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – File path at which to save, ending with the desired filename.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.detector.Detector.load">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/detector.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.detector.Detector.load" title="Permalink to this definition"></a></dt>
<dd><p>Load the detector object from disc (via pickling).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – File path at which to load, ending with the desired filename.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function will unpickle data from the provied path. The pickle module
is not intended to be secure against erroneous or maliciously constructed data.
Never unpickle data received from an untrusted or unauthenticated source.</p>
</aside>
</dd></dl>

</dd></dl>

</section>
<section id="module-xrd_simulator.motion">
<span id="motion"></span><h2>motion<a class="headerlink" href="#module-xrd_simulator.motion" title="Permalink to this headline"></a></h2>
<p>The motion module is used to represent a rigid body motion. During diffraction from a
<a class="reference internal" href="#xrd_simulator.polycrystal.Polycrystal" title="xrd_simulator.polycrystal.Polycrystal"><code class="xref py py-class docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal.Polycrystal</span></code></a> the <a class="reference internal" href="#xrd_simulator.motion.RigidBodyMotion" title="xrd_simulator.motion.RigidBodyMotion"><code class="xref py py-class docutils literal notranslate"><span class="pre">xrd_simulator.motion.RigidBodyMotion</span></code></a>
object describes how the sample is translating and rotating. The motion can be used to update the
polycrystal position via the <a class="reference internal" href="#xrd_simulator.polycrystal.Polycrystal.transform" title="xrd_simulator.polycrystal.Polycrystal.transform"><code class="xref py py-func docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal.Polycrystal.transform()</span></code></a> function.</p>
<p>Here is a minimal example of how to instantiate a rigid body motion object, apply the motion to a pointcloud
and save the motion to disc:</p>
<blockquote>
<div><dl>
<dt>Examples:</dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">xrd_simulator.motion</span> <span class="kn">import</span> <span class="n">RigidBodyMotion</span>

<span class="c1"># The motion is described by a rotation axis and a translation vector</span>
<span class="n">motion</span> <span class="o">=</span> <span class="n">RigidBodyMotion</span><span class="p">(</span><span class="n">rotation_axis</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)]),</span>
                         <span class="n">rotation_angle</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">2.0</span><span class="p">),</span>
                         <span class="n">translation</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">123</span><span class="p">,</span> <span class="o">-</span><span class="mf">153.3</span><span class="p">,</span> <span class="mf">3.42</span><span class="p">]))</span>

<span class="c1"># The motion can be applied to transform a set of points</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">transformed_points</span> <span class="o">=</span> <span class="n">motion</span><span class="p">(</span> <span class="n">points</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mf">0.421</span> <span class="p">)</span>

<span class="c1"># The motion may be saved to disc for later usage.</span>
<span class="n">motion</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s1">&#39;my_motion&#39;</span><span class="p">)</span>
<span class="n">motion_loaded_from_disc</span> <span class="o">=</span> <span class="n">RigidBodyMotion</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;my_motion.motion&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd>
</dl>
</div></blockquote>
<p>Below follows a detailed description of the RigidBodyMotion class attributes and functions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="xrd_simulator.motion.RigidBodyMotion">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xrd_simulator.motion.</span></span><span class="sig-name descname"><span class="pre">RigidBodyMotion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotation_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/motion.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.motion.RigidBodyMotion" title="Permalink to this definition"></a></dt>
<dd><p>Rigid body transformation of euclidean points by an euler axis rotation and a translation.</p>
<p>A rigid body motion is defined in the laboratory coordinates system.</p>
<p>The Motion is parametric in the interval time=[0,1] and will perform a rigid body transformation
of a point x by linearly uniformly rotating it from [0, rotation_angle] and translating [0, translation].
I.e if called at a time time=t the motion will first rotate the point <code class="docutils literal notranslate"><span class="pre">t*rotation_angle</span></code> radians
around <code class="docutils literal notranslate"><span class="pre">rotation_axis</span></code> and next translate the point by the vector <code class="docutils literal notranslate"><span class="pre">t*translation</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rotation_axis</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Rotation axis <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code></p></li>
<li><p><strong>rotation_angle</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Radians for final rotation, when time=1.</p></li>
<li><p><strong>translation</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Translation vector <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code></p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.motion.RigidBodyMotion.rotation_axis">
<span class="sig-name descname"><span class="pre">rotation_axis</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/motion.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.motion.RigidBodyMotion.rotation_axis" title="Permalink to this definition"></a></dt>
<dd><p>Rotation axis <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.motion.RigidBodyMotion.rotation_angle">
<span class="sig-name descname"><span class="pre">rotation_angle</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/motion.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.motion.RigidBodyMotion.rotation_angle" title="Permalink to this definition"></a></dt>
<dd><p>Radians for final rotation, when time=1.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.motion.RigidBodyMotion.translation">
<span class="sig-name descname"><span class="pre">translation</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/motion.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.motion.RigidBodyMotion.translation" title="Permalink to this definition"></a></dt>
<dd><p>Translation vector <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.motion.RigidBodyMotion.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/motion.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.motion.RigidBodyMotion.__call__" title="Permalink to this definition"></a></dt>
<dd><p>Find the transformation of a set of points at a prescribed time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vectors</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – A set of points to be transformed (<code class="docutils literal notranslate"><span class="pre">shape=(3,N)</span></code>)</p></li>
<li><p><strong>time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Time to compute for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Transformed vectors (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) of <code class="docutils literal notranslate"><span class="pre">shape=(3,N)</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.motion.RigidBodyMotion.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/motion.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.motion.RigidBodyMotion.rotate" title="Permalink to this definition"></a></dt>
<dd><p>Find the rotational transformation of a set of vectors at a prescribed time.</p>
<p>NOTE: This function only applies the rigid body rotation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vectors</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – A set of points in 3d euclidean space to be rotated (<code class="docutils literal notranslate"><span class="pre">shape=(3,N)</span></code>)</p></li>
<li><p><strong>time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Time to compute for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Transformed vectors (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) of <code class="docutils literal notranslate"><span class="pre">shape=(3,N)</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.motion.RigidBodyMotion.translate">
<span class="sig-name descname"><span class="pre">translate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vectors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/motion.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.motion.RigidBodyMotion.translate" title="Permalink to this definition"></a></dt>
<dd><p>Find the translational transformation of a set of points at a prescribed time.</p>
<p>NOTE: This function only applies the rigid body translation</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vectors</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – A set of points in 3d euclidean space to be rotated (<code class="docutils literal notranslate"><span class="pre">shape=(3,N)</span></code>)</p></li>
<li><p><strong>time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Time to compute for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Transformed vectors (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) of <code class="docutils literal notranslate"><span class="pre">shape=(3,N)</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.motion.RigidBodyMotion.save">
<span class="sig-name descname"><span class="pre">save</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/motion.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.motion.RigidBodyMotion.save" title="Permalink to this definition"></a></dt>
<dd><p>Save the motion object to disc (via pickling).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – File path at which to save, ending with the desired filename.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="xrd_simulator.motion.RigidBodyMotion.load">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/motion.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.motion.RigidBodyMotion.load" title="Permalink to this definition"></a></dt>
<dd><p>Load the motion object from disc (via pickling).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code>) – File path at which to load, ending with the desired filename.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This function will unpickle data from the provied path. The pickle module
is not intended to be secure against erroneous or maliciously constructed data.
Never unpickle data received from an untrusted or unauthenticated source.</p>
</aside>
</dd></dl>

</dd></dl>

</section>
<section id="module-xrd_simulator.templates">
<span id="templates"></span><h2>templates<a class="headerlink" href="#module-xrd_simulator.templates" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">templates</span></code> module allows for fast creation of a few select sample types and diffraction geometries without having to
worry about any of the “under the hood” scripting.</p>
<dl class="py function">
<dt class="sig sig-object py" id="xrd_simulator.templates.s3dxrd">
<span class="sig-prename descclassname"><span class="pre">xrd_simulator.templates.</span></span><span class="sig-name descname"><span class="pre">s3dxrd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/templates.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.templates.s3dxrd" title="Permalink to this definition"></a></dt>
<dd><p>Construct a scaning-three-dimensional-xray diffraction experiment.</p>
<p>This is a helper/utility function for quickly creating an experiment. For full controll
over the diffraction geometry consider custom creation of the primitive quantities:
(<a class="reference internal" href="#xrd_simulator.beam.Beam" title="xrd_simulator.beam.Beam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.beam.Beam</span></code></a>), and (<a class="reference internal" href="#xrd_simulator.detector.Detector" title="xrd_simulator.detector.Detector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.detector.Detector</span></code></a>) seperately.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>parameters</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">dict</span></code>) – <p>Dictionary with fields as</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;detector_distance&quot;</span></code><span class="classifier">(<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) Distance form sample origin to</span></dt><dd><p>detector centre in units of microns.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;number_of_detector_pixels_z&quot;</span></code><span class="classifier">(<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) Number of detector pixels</span></dt><dd><p>along z-axis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;number_of_detector_pixels_y&quot;</span></code><span class="classifier">(<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) Number of detector pixels</span></dt><dd><p>along y-axis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;detector_center_pixel_z&quot;</span></code><span class="classifier">(<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) Intersection pixel coordinate between</span></dt><dd><p>beam centroid line and detector along z-axis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;detector_center_pixel_y&quot;</span></code><span class="classifier">(<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) Intersection pixel coordinate between</span></dt><dd><p>beam centroid line and detector along y-axis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;pixel_side_length_z&quot;</span></code><span class="classifier">(<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) Detector pixel side length in units</span></dt><dd><p>of microns along z-axis.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;pixel_side_length_y&quot;</span></code><span class="classifier">(<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) Detector pixel side length in units</span></dt><dd><p>of microns along y-axis.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">&quot;wavelength&quot;</span></code>                  : (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) Wavelength in units of Angstrom.</p>
<dl>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;beam_side_length_z&quot;</span></code><span class="classifier">(<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) Beam side length in units</span></dt><dd><p>of microns.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;beam_side_length_y&quot;</span></code><span class="classifier">(<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) Beam side length in units</span></dt><dd><p>of microns.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;rotation_step&quot;</span></code><span class="classifier">(<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) Angular frame integration step in</span></dt><dd><p>units of radians.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">&quot;rotation_axis&quot;</span></code><span class="classifier">(<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>)  Axis around which to</span></dt><dd><p>positively rotate the sample by <code class="docutils literal notranslate"><span class="pre">rotation_step</span></code> radians.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(<a class="reference internal" href="#xrd_simulator.beam.Beam" title="xrd_simulator.beam.Beam"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.beam.Beam</span></code></a>),
(<a class="reference internal" href="#xrd_simulator.detector.Detector" title="xrd_simulator.detector.Detector"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.detector.Detector</span></code></a>), (<a class="reference internal" href="#xrd_simulator.motion.RigidBodyMotion" title="xrd_simulator.motion.RigidBodyMotion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.motion.RigidBodyMotion</span></code></a>).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(<code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator</span></code>) objects defining an experiment</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">xrd_simulator</span> <span class="kn">import</span> <span class="n">templates</span>

<span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;detector_distance&quot;</span><span class="p">:</span> <span class="mf">191023.9164</span><span class="p">,</span>
    <span class="s2">&quot;detector_center_pixel_z&quot;</span><span class="p">:</span> <span class="mf">256.2345</span><span class="p">,</span>
    <span class="s2">&quot;detector_center_pixel_y&quot;</span><span class="p">:</span> <span class="mf">255.1129</span><span class="p">,</span>
    <span class="s2">&quot;pixel_side_length_z&quot;</span><span class="p">:</span> <span class="mf">181.4234</span><span class="p">,</span>
    <span class="s2">&quot;pixel_side_length_y&quot;</span><span class="p">:</span> <span class="mf">180.2343</span><span class="p">,</span>
    <span class="s2">&quot;number_of_detector_pixels_z&quot;</span><span class="p">:</span> <span class="mi">512</span><span class="p">,</span>
    <span class="s2">&quot;number_of_detector_pixels_y&quot;</span><span class="p">:</span> <span class="mi">512</span><span class="p">,</span>
    <span class="s2">&quot;wavelength&quot;</span><span class="p">:</span> <span class="mf">0.285227</span><span class="p">,</span>
    <span class="s2">&quot;beam_side_length_z&quot;</span><span class="p">:</span> <span class="mi">512</span> <span class="o">*</span> <span class="mf">200.</span><span class="p">,</span>
    <span class="s2">&quot;beam_side_length_y&quot;</span><span class="p">:</span> <span class="mi">512</span> <span class="o">*</span> <span class="mf">200.</span><span class="p">,</span>
    <span class="s2">&quot;rotation_step&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="s2">&quot;rotation_axis&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="p">}</span>

<span class="n">beam</span><span class="p">,</span> <span class="n">detector</span><span class="p">,</span> <span class="n">motion</span> <span class="o">=</span> <span class="n">templates</span><span class="o">.</span><span class="n">s3dxrd</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xrd_simulator.templates.polycrystal_from_odf">
<span class="sig-prename descclassname"><span class="pre">xrd_simulator.templates.</span></span><span class="sig-name descname"><span class="pre">polycrystal_from_odf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orientation_density_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_crystals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_bounding_cylinder_height</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_bounding_cylinder_radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit_cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sgname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_to_cif_file=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximum_sampling_bin_seperation=0.08726646259971647</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strain_tensor=&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/templates.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.templates.polycrystal_from_odf" title="Permalink to this definition"></a></dt>
<dd><p>Fill a cylinder with crystals from a given orientation density function.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">orientation_density_function</span></code> is sampled by discretizing orientation space over the unit
quarternions. Each bin is assigned its apropiate probability, assuming the
<code class="docutils literal notranslate"><span class="pre">orientation_density_function</span></code> is approximately constant over a single bin. Each sampled
orientation is constructed by first drawing a random bin and next drawing uniformly from
within that bin, again assuming that <code class="docutils literal notranslate"><span class="pre">orientation_density_function</span></code> is approximately constant
over a bin.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orientation_density_function</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code>) – orientation_density_function(x, q) -&gt;
<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> where input variable <code class="docutils literal notranslate"><span class="pre">x</span></code> is a <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> of shape <code class="docutils literal notranslate"><span class="pre">(3,)</span></code>
representing a spatial coordinate in the cylinder (x,y,z) and <code class="docutils literal notranslate"><span class="pre">q</span></code> is a
<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> of shape <code class="docutils literal notranslate"><span class="pre">(4,)</span></code> representing a orientation in so3 by a unit
quarternion. The format of the quarternion is “scalar last”
(same as in scipy.spatial.transform.Rotation).</p></li>
<li><p><strong>number_of_crystals</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Approximate number of crystal elements to compose the
cylinder volume.</p></li>
<li><p><strong>sample_bounding_cylinder_height</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Height of sample cylinder in units of
microns.</p></li>
<li><p><strong>sample_bounding_cylinder_radius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Radius of sample cylinder in units of
microns.</p></li>
<li><p><strong>unit_cell</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Crystal unit cell representation of the form
[a,b,c,alpha,beta,gamma], where alpha,beta and gamma are in units of degrees while
a,b and c are in units of anstrom.</p></li>
<li><p><strong>sgname</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>) – Name of space group , e.g ‘P3221’ for quartz, SiO2, for instance</p></li>
<li><p><strong>path_to_cif_file</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>) – Path to CIF file. Defaults to None, in which case no structure
factors are computed.</p></li>
<li><p><strong>maximum_sampling_bin_seperation</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Discretization steplength of orientation
space using spherical coordinates over the unit quarternions in units of radians.
A smaller steplength gives more accurate sampling of the input
<code class="docutils literal notranslate"><span class="pre">orientation_density_function</span></code> but is computationally slower.</p></li>
<li><p><strong>strain_tensor</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">callable</span></code>) – Strain tensor field over sample cylinder.
strain_tensor(x) -&gt; <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> of shape <code class="docutils literal notranslate"><span class="pre">(3,3)</span></code> where input variable <code class="docutils literal notranslate"><span class="pre">x</span></code> is
a <code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code> of shape <code class="docutils literal notranslate"><span class="pre">(3,)</span></code> representing a spatial coordinate in the
cylinder (x,y,z).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(<a class="reference internal" href="#xrd_simulator.polycrystal.Polycrystal" title="xrd_simulator.polycrystal.Polycrystal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal.Polycrystal</span></code></a>)</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">xrd_simulator.templates</span> <span class="kn">import</span> <span class="n">polycrystal_from_odf</span>


<span class="c1"># uniform orientation distribution function.</span>
<span class="k">def</span> <span class="nf">ODF</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">q</span><span class="p">):</span> <span class="k">return</span> <span class="mf">1.</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>


<span class="n">number_of_crystals</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">bounding_height</span> <span class="o">=</span> <span class="mf">50.0</span>
<span class="n">bounding_radius</span> <span class="o">=</span> <span class="mf">25.0</span>
<span class="n">unit_cell</span> <span class="o">=</span> <span class="p">[</span><span class="mf">4.926</span><span class="p">,</span> <span class="mf">4.926</span><span class="p">,</span> <span class="mf">5.4189</span><span class="p">,</span> <span class="mf">90.</span><span class="p">,</span> <span class="mf">90.</span><span class="p">,</span> <span class="mf">120.</span><span class="p">]</span>
<span class="n">sgname</span> <span class="o">=</span> <span class="s1">&#39;P3221&#39;</span><span class="p">,</span>  <span class="c1"># Quartz</span>
<span class="n">max_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">10.0</span><span class="p">)</span>
<span class="n">path_to_cif_file</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span> <span class="nf">strain_tensor</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.02</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">/</span> <span class="n">bounding_height</span><span class="p">],</span>
                                       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>  <span class="c1"># Linear strain gradient along rotation axis.</span>


<span class="n">polycrystal</span> <span class="o">=</span> <span class="n">polycrystal_from_odf</span><span class="p">(</span><span class="n">ODF</span><span class="p">,</span>
                                   <span class="n">number_of_crystals</span><span class="p">,</span>
                                   <span class="n">bounding_height</span><span class="p">,</span>
                                   <span class="n">bounding_radius</span><span class="p">,</span>
                                   <span class="n">unit_cell</span><span class="p">,</span>
                                   <span class="n">sgname</span><span class="p">,</span>
                                   <span class="n">path_to_cif_file</span><span class="p">,</span>
                                   <span class="n">max_bin</span><span class="p">,</span>
                                   <span class="n">strain_tensor</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xrd_simulator.templates.get_uniform_powder_sample">
<span class="sig-prename descclassname"><span class="pre">xrd_simulator.templates.</span></span><span class="sig-name descname"><span class="pre">get_uniform_powder_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_bounding_radius</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">number_of_grains</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unit_cell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sgname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strain_tensor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([[0.,</span> <span class="pre">0.,</span> <span class="pre">0.],</span> <span class="pre">[0.,</span> <span class="pre">0.,</span> <span class="pre">0.],</span> <span class="pre">[0.,</span> <span class="pre">0.,</span> <span class="pre">0.]])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path_to_cif_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/templates.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.templates.get_uniform_powder_sample" title="Permalink to this definition"></a></dt>
<dd><p>Generate a polycyrystal with grains overlayed at the origin and orientations drawn uniformly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sample_bounding_radius</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Bounding radius of sample. All tetrahedral crystal
elements will be overlayed within a sphere of <code class="docutils literal notranslate"><span class="pre">sample_bounding_radius</span></code> radius.</p></li>
<li><p><strong>number_of_grains</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Number of grains composing the polycrystal sample.</p></li>
<li><p><strong>unit_cell</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Crystal unit cell representation of the form
[a,b,c,alpha,beta,gamma], where alpha,beta and gamma are in units of degrees while
a,b and c are in units of anstrom.</p></li>
<li><p><strong>sgname</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>) – Name of space group , e.g ‘P3221’ for quartz, SiO2, for instance</p></li>
<li><p><strong>strain_tensor</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Strain tensor to apply to all tetrahedral crystal
elements contained within the sample. <code class="docutils literal notranslate"><span class="pre">shape=(3,3)</span></code>.</p></li>
<li><p><strong>path_to_cif_file</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">string</span></code>) – Path to CIF file. Defaults to None, in which case no structure
factors are computed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>(<a class="reference internal" href="#module-xrd_simulator.polycrystal" title="xrd_simulator.polycrystal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal</span></code></a>) A polycyrystal sample with <code class="docutils literal notranslate"><span class="pre">number_of_grains</span></code> grains.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">xrd_simulator</span> <span class="kn">import</span> <span class="n">templates</span>

<span class="n">polycrystal</span> <span class="o">=</span> <span class="n">templates</span><span class="o">.</span><span class="n">get_uniform_powder_sample</span><span class="p">(</span>
    <span class="n">sample_bounding_radius</span><span class="o">=</span><span class="mf">1.203</span><span class="p">,</span>
    <span class="n">number_of_grains</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
    <span class="n">unit_cell</span><span class="o">=</span><span class="p">[</span><span class="mf">4.926</span><span class="p">,</span> <span class="mf">4.926</span><span class="p">,</span> <span class="mf">5.4189</span><span class="p">,</span> <span class="mf">90.</span><span class="p">,</span> <span class="mf">90.</span><span class="p">,</span> <span class="mf">120.</span><span class="p">],</span>
    <span class="n">sgname</span><span class="o">=</span><span class="s1">&#39;P3221&#39;</span><span class="p">,</span>
    <span class="n">strain_tensor</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0012</span><span class="p">],</span>
                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-xrd_simulator.scattering_unit">
<span id="scattering-unit"></span><h2>scattering_unit<a class="headerlink" href="#module-xrd_simulator.scattering_unit" title="Permalink to this headline"></a></h2>
<p>A scattering unit is generated by the <a class="reference internal" href="#xrd_simulator.polycrystal.Polycrystal" title="xrd_simulator.polycrystal.Polycrystal"><code class="xref py py-class docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal.Polycrystal</span></code></a> as the beam interacts with the sample.
For advanced users it can be usefull to interact with the scattering units, this is preferably done via the
<a class="reference internal" href="#xrd_simulator.detector.Detector" title="xrd_simulator.detector.Detector"><code class="xref py py-class docutils literal notranslate"><span class="pre">xrd_simulator.detector.Detector</span></code></a> which will hold all the scatterign units created during diffraction
from the polycrystal.</p>
<dl class="py class">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">xrd_simulator.scattering_unit.</span></span><span class="sig-name descname"><span class="pre">ScatteringUnit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">convex_hull</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scattered_wave_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incident_wave_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">incident_polarization_vector</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hkl_indx</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit" title="Permalink to this definition"></a></dt>
<dd><p>Defines a scattering region in space as a single crystal as a convex polyhedra.</p>
<p>The scattering unit is described in laboratory coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>convex_hull</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.spatial.ConvexHull</span></code>) – Object describing the convex hull of the scattering unit.</p></li>
<li><p><strong>scattered_wave_vector</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Scattered wavevector <code class="docutils literal notranslate"><span class="pre">`shape=(3,)`</span></code></p></li>
<li><p><strong>incident_wave_vector</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Incident wavevector <code class="docutils literal notranslate"><span class="pre">`shape=(3,)`</span></code></p></li>
<li><p><strong>wavelength</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Wavelength of xrays in units of angstrom.</p></li>
<li><p><strong>incident_polarization_vector</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Unit vector of linear polarization <code class="docutils literal notranslate"><span class="pre">`shape=(3,)`</span></code></p></li>
<li><p><strong>rotation_axis</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Sample motion rotation axis <code class="docutils literal notranslate"><span class="pre">`shape=(3,)`</span></code></p></li>
<li><p><strong>time</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Parametric value in range [0,1] determining at which instance during sample
motion the scattering occured.</p></li>
<li><p><strong>phase</strong> (<a class="reference internal" href="#xrd_simulator.phase.Phase" title="xrd_simulator.phase.Phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.phase.Phase</span></code></a>) – The phase of the scattering unit.</p></li>
<li><p><strong>hkl_indx</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code>) – Index of Miller index in the <cite>phase.miller_indices</cite> list.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.convex_hull">
<span class="sig-name descname"><span class="pre">convex_hull</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.convex_hull" title="Permalink to this definition"></a></dt>
<dd><p>Object describing the convex hull of the scattering unit.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.spatial.ConvexHull</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.scattered_wave_vector">
<span class="sig-name descname"><span class="pre">scattered_wave_vector</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.scattered_wave_vector" title="Permalink to this definition"></a></dt>
<dd><p>Scattered wavevector <code class="docutils literal notranslate"><span class="pre">`shape=(3,)`</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.incident_wave_vector">
<span class="sig-name descname"><span class="pre">incident_wave_vector</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.incident_wave_vector" title="Permalink to this definition"></a></dt>
<dd><p>Incident wavevector <code class="docutils literal notranslate"><span class="pre">`shape=(3,)`</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.wavelength">
<span class="sig-name descname"><span class="pre">wavelength</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.wavelength" title="Permalink to this definition"></a></dt>
<dd><p>Wavelength of xrays in units of angstrom.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.incident_polarization_vector">
<span class="sig-name descname"><span class="pre">incident_polarization_vector</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.incident_polarization_vector" title="Permalink to this definition"></a></dt>
<dd><p>Unit vector of linear polarization <code class="docutils literal notranslate"><span class="pre">`shape=(3,)`</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.rotation_axis">
<span class="sig-name descname"><span class="pre">rotation_axis</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.rotation_axis" title="Permalink to this definition"></a></dt>
<dd><p>Sample motion rotation axis <code class="docutils literal notranslate"><span class="pre">`shape=(3,)`</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.time">
<span class="sig-name descname"><span class="pre">time</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.time" title="Permalink to this definition"></a></dt>
<dd><p>Parametric value in range [0,1] determining at which instance during sample
motion the scattering occured.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.phase">
<span class="sig-name descname"><span class="pre">phase</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.phase" title="Permalink to this definition"></a></dt>
<dd><p>The phase of the scattering unit.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#xrd_simulator.phase.Phase" title="xrd_simulator.phase.Phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">xrd_simulator.phase.Phase</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.hkl_indx">
<span class="sig-name descname"><span class="pre">hkl_indx</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.hkl_indx" title="Permalink to this definition"></a></dt>
<dd><p>Index of Miller index in the <cite>phase.miller_indices</cite> list.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.hkl">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">hkl</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.hkl" title="Permalink to this definition"></a></dt>
<dd><p>Miller indices [h,k,l] <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>hkl (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.real_structure_factor">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">real_structure_factor</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.real_structure_factor" title="Permalink to this definition"></a></dt>
<dd><p>Real part of unit cell structure factor</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>hkl (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.imaginary_structure_factor">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">imaginary_structure_factor</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.imaginary_structure_factor" title="Permalink to this definition"></a></dt>
<dd><p>Imaginary part of unit cell structure factor</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>hkl (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.lorentz_factor">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">lorentz_factor</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.lorentz_factor" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Lorentz intensity factor for a scattering_unit.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.polarization_factor">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">polarization_factor</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.polarization_factor" title="Permalink to this definition"></a></dt>
<dd><p>Compute the Polarization intensity factor for a scattering_unit.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.centroid">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">centroid</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.centroid" title="Permalink to this definition"></a></dt>
<dd><p>centroid of the scattering region. <code class="docutils literal notranslate"><span class="pre">shape=(3,)</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>centroid (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="xrd_simulator.scattering_unit.ScatteringUnit.volume">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">volume</span></span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/scattering_unit.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.scattering_unit.ScatteringUnit.volume" title="Permalink to this definition"></a></dt>
<dd><p>volume of the scattering region volume</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>volume (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-xrd_simulator.laue">
<span id="laue"></span><h2>laue<a class="headerlink" href="#module-xrd_simulator.laue" title="Permalink to this headline"></a></h2>
<p>Collection of functions for solving time dependent Laue equations for arbitrary rigid body motions.
This module is mainly used internally by the <a class="reference internal" href="#xrd_simulator.polycrystal.Polycrystal" title="xrd_simulator.polycrystal.Polycrystal"><code class="xref py py-class docutils literal notranslate"><span class="pre">xrd_simulator.polycrystal.Polycrystal</span></code></a>. However,
for the advanced user, access to these functions may be of interest.</p>
<dl class="py function">
<dt class="sig sig-object py" id="xrd_simulator.laue.get_G">
<span class="sig-prename descclassname"><span class="pre">xrd_simulator.laue.</span></span><span class="sig-name descname"><span class="pre">get_G</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">U</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G_hkl</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/laue.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.laue.get_G" title="Permalink to this definition"></a></dt>
<dd><p>Compute the diffraction vector</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{G} = \boldsymbol{U}\boldsymbol{B}\boldsymbol{G}_{hkl}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>U</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) Orientation matrix of <code class="docutils literal notranslate"><span class="pre">shape=(3,3)</span></code> (unitary) – </p></li>
<li><p><strong>B</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Reciprocal to grain coordinate mapping matrix of <code class="docutils literal notranslate"><span class="pre">shape=(3,3)</span></code>.</p></li>
<li><p><strong>G_hkl</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Miller indices, i.e the h,k,l integers (<code class="docutils literal notranslate"><span class="pre">shape=(3,n)</span></code>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Sample coordinate system diffraction vector. (<code class="docutils literal notranslate"><span class="pre">shape=(3,n)</span></code>)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>G (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xrd_simulator.laue.get_bragg_angle">
<span class="sig-prename descclassname"><span class="pre">xrd_simulator.laue.</span></span><span class="sig-name descname"><span class="pre">get_bragg_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/laue.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.laue.get_bragg_angle" title="Permalink to this definition"></a></dt>
<dd><p>Compute a Bragg angle given a diffraction (scattering) vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Sample coordinate system diffraction vector. (<code class="docutils literal notranslate"><span class="pre">shape=(3,n)</span></code>)</p></li>
<li><p><strong>wavelength</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Photon wavelength in units of angstrom.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>in units of radians. (<code class="docutils literal notranslate"><span class="pre">shape=(n,)</span></code>)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Bragg angles (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xrd_simulator.laue.get_sin_theta_and_norm_G">
<span class="sig-prename descclassname"><span class="pre">xrd_simulator.laue.</span></span><span class="sig-name descname"><span class="pre">get_sin_theta_and_norm_G</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wavelength</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/laue.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.laue.get_sin_theta_and_norm_G" title="Permalink to this definition"></a></dt>
<dd><p>Compute a Bragg angle given a diffraction (scattering) vector.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span> <span class="pre">array</span></code>) – Sample coordinate system diffraction vector.</p></li>
<li><p><strong>wavelength</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Photon wavelength in units of angstrom.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>in units of radians and ||G||.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>sin(Bragg angle) (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xrd_simulator.laue.get_tangens_half_angle_equation">
<span class="sig-prename descclassname"><span class="pre">xrd_simulator.laue.</span></span><span class="sig-name descname"><span class="pre">get_tangens_half_angle_equation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rhat</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/laue.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.laue.get_tangens_half_angle_equation" title="Permalink to this definition"></a></dt>
<dd><p>Find coefficient to the equation</p>
<div class="math notranslate nohighlight">
\[\rho_0 \cos(t \Delta \omega) + \rho_1 \sin(t \Delta \omega) + \rho_2 = 0. \quad\quad (1)\]</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="xrd_simulator.laue.find_solutions_to_tangens_half_angle_equation">
<span class="sig-prename descclassname"><span class="pre">xrd_simulator.laue.</span></span><span class="sig-name descname"><span class="pre">find_solutions_to_tangens_half_angle_equation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rho_0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho_1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rho_2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delta_omega</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/fable-3dxrd/xrd_simulator/blob/main/xrd_simulator/laue.py/"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#xrd_simulator.laue.find_solutions_to_tangens_half_angle_equation" title="Permalink to this definition"></a></dt>
<dd><p>Find all solutions, <code class="xref py py-obj docutils literal notranslate"><span class="pre">t</span></code>, to the equation (maximum 2 solutions exists)</p>
<div class="math notranslate nohighlight">
\[\rho_0 \cos(t \Delta \omega) + \rho_1 \sin(t \Delta \omega) + \rho_2 = 0. \quad\quad (1)\]</div>
<p>by rewriting as</p>
<div class="math notranslate nohighlight">
\[(\rho_2 - \rho_0) s^2 + 2 \rho_1 s + (\rho_0 + \rho_2) = 0. \quad\quad (2)\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[s = \tan(t \Delta \omega / 2). \quad\quad (3)\]</div>
<p>and</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\Delta \omega\]</div>
</div></blockquote>
<p>is a rotation angle</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rho_0</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Coefficients rho_0,rho_1 and rho_2 of equation (1).</p></li>
<li><p><strong>rho_1</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Coefficients rho_0,rho_1 and rho_2 of equation (1).</p></li>
<li><p><strong>rho_2</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Coefficients rho_0,rho_1 and rho_2 of equation (1).</p></li>
<li><p><strong>delta_omega</strong> (<code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code>) – Radians of rotation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>solutions if existing otherwise returns None.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(<code class="xref py py-obj docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-obj docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>)</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Axel Henningsson.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>